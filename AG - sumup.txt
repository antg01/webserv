---

# Configuration, Fichiers statiques & Outils

### ğŸ”¹ Config Parser â€“ rÃ©sumÃ© rapide

* Lit un fichier `.conf` et construit une structure en mÃ©moire (`Config`).
* Chaque `server {}` â†’ `ServerBlock` (ports, root, index, error\_pages, locations).
* Chaque `location {}` â†’ `LocationBlock` (methods, autoindex, upload\_store, cgi\_pass, returnâ€¦).
* Validation de la syntaxe et organisation en blocs hiÃ©rarchiques.
* **A** utilise `listen` pour ouvrir les sockets, **B** utilise `root/index/methods` pour router les requÃªtes HTTP.

---

### ğŸ”¹ ConfigValidator â€“ rÃ©sumÃ© rapide

* VÃ©rifie que la config est **cohÃ©rente et exploitable** avant lancement.
* ContrÃ´le : ports (1â€“65535), `root` existant, `upload_store` existant, `error_page` fichiers valides.
* Parcourt tous les `ServerBlock` et `LocationBlock` pour dÃ©tecter erreurs.
* En cas de problÃ¨me â†’ stoppe avec un message explicite (`ValidationError`).
* **A** et **B** peuvent utiliser la config en toute confiance (plus besoin de revalider).

---

### ğŸ”¹ DirectoryResolver / Autoindex â€“ rÃ©sumÃ© rapide

* DÃ©cide quoi faire quand une URL cible un **rÃ©pertoire**.
* Cherche dâ€™abord un **index file** (ex: `index.html`).
* Si absent â†’ gÃ©nÃ¨re une page **autoindex HTML** si activÃ©.
* Sinon â†’ renvoie **403 Forbidden**.
* **B (HTTP)** lâ€™utilise pour servir soit un fichier, soit un listing, soit une erreur.

---

### ğŸ”¹ Uploads â€“ rÃ©sumÃ© rapide

* Chaque `location` peut dÃ©finir un dossier cible avec `upload_store`.
* Les requÃªtes **POST** y sauvegardent les fichiers envoyÃ©s.
* La taille est limitÃ©e par `client_max_body_size` (directive du serveur).
* Si le fichier est trop gros â†’ `413 Payload Too Large`.
* **B (HTTP)** gÃ¨re lâ€™Ã©criture dans `upload_store` et la rÃ©ponse (`201 Created`).

---

### ğŸ”¹ Error Pages â€“ rÃ©sumÃ© rapide

* Chaque `server` peut mapper un code (ex: `404`) vers un fichier HTML (`error_page 404 /errors/404.html;`).
* Les chemins sont rÃ©solus par rapport au `root` du serveur.
* `ConfigValidator` vÃ©rifie que ces fichiers existent vraiment.
* Si non dÃ©fini â†’ fallback sur les pages par dÃ©faut dans `www/errors/`.
* **B (HTTP)** sert la page correspondante avec le bon code dâ€™erreur.

---
---

# **schÃ©ma ASCII** clair du flux complet entre **A (RÃ©seau)**, **B (HTTP/CGI)** et **C (Config & Fichiers)**

```
           â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
           â”‚                       Client                         â”‚
           â”‚                 (browser / curl)                     â”‚
           â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                           â”‚ TCP
                           â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                          A â€” RÃ©seau (I/O)                                â”‚
â”‚  poll/select/epoll/kqueue (non-bloquant)                                 â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                 â”‚
â”‚   â”‚ listen socket â”‚â—„â”€â”€â”€â”€â”€â”€â”€â”€â”‚ cfg.collectAllListens()  â”‚â—„â”€â”€â”€â”€â”€â”          â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜      â”‚          â”‚
â”‚          â”‚accept()                                            â”‚          â”‚
â”‚          â–¼                                                     â”‚         â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   recv()   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”‚         â”‚
â”‚   â”‚ client socket â”‚â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–ºâ”‚  buffer requÃªte HTTP    â”‚     â”‚         â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜            â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â”‚         â”‚
â”‚          â–²                               â”‚                     â”‚         â”‚
â”‚          â”‚send()  â—„â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  rÃ©ponse HTTP       â”‚         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                           â”‚
                                           â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                        B â€” HTTP & CGI                                    â”‚
â”‚  1) Parse requÃªte (mÃ©thode, path, headers, body)                         â”‚
â”‚  2) SÃ©lection Server/Location via C.Config                               â”‚
â”‚  3) Applique rÃ¨gles: methods, return, cgi_pass, upload_store, etc.       â”‚
â”‚  4) RÃ©sout ressource (statique / autoindex / CGI / erreur)               â”‚
â”‚                                                                          â”‚
â”‚     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”            â”‚
â”‚     â”‚     C â€” Config & Fichiers (ton module)                â”‚            â”‚
â”‚     â”‚   - ConfigParser + ConfigValidator                    â”‚            â”‚
â”‚     â”‚   - resolvePath(root, url)                            â”‚            â”‚
â”‚     â”‚   - DirectoryResolver (index/autoindex/403)           â”‚            â”‚
â”‚     â”‚   - generateAutoIndex(dir, url)                       â”‚            â”‚
â”‚     â”‚   - error_page mapping                                â”‚            â”‚
â”‚     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜            â”‚
â”‚        â–²                 â–²                     â–²                         â”‚
â”‚        â”‚                 â”‚                     â”‚                         â”‚
â”‚   ServerBlock       LocationBlock          www/ , errors/                â”‚
â”‚  (listen,root,â€¦)   (methods,autoindex,â€¦)  (contenu statique)             â”‚
â”‚                                                                          â”‚
â”‚  5) Construit rÃ©ponse: status, headers (CL/CT), body                     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### LÃ©gende rapide

* **A (RÃ©seau)** : ouvre les ports de `Config`, gÃ¨re `poll()` et le transport dâ€™octets (recv/send).
* **B (HTTP/CGI)** : comprend HTTP, choisit la ressource, appelle tes utilitaires.
* **C (toi)** : fournit la config validÃ©e + outils fichiers (resolvePath, autoindex, error pages).

---

## Mini scÃ©nario â€” `GET /static/` sur `site1`

1. **A** reÃ§oit des octets â†’ place la requÃªte dans un buffer.
2. **B** parse : mÃ©thode=`GET`, path=`/static/`, host/port â†’ trouve le `ServerBlock`.
3. **B** choisit la `Location` `/static/` â†’ lit `root`, `index`, `autoindex`.
4. **B** appelle **C** :

   * `abs = resolvePath(serverRoot|locationRoot, "/static/")`
   * `isDirectory(abs)` â†’ oui
   * `resolveDirectoryRequest(abs, "/static/", indexList, autoindexOn)`

     * sâ€™il y a un `index.html` â†’ **ServeIndexFile**
     * sinon si `autoindex on` â†’ **ServeAutoIndex** (HTML gÃ©nÃ©rÃ©)
     * sinon â†’ **Forbidden (403)**
5. **B** construit la rÃ©ponse HTTP (status + headers + body).
6. **A** envoie la rÃ©ponse sur le socket client.

---

## Mini scÃ©nario â€” `POST /upload` avec fichier

1. **B** vÃ©rifie `methods` et `client_max_body_size`.
2. **B** rÃ©cupÃ¨re `upload_store` dans la `Location` â†’ Ã©crit le fichier.
3. RÃ©ponse : `201 Created` (ou `413` si trop gros), **A** lâ€™envoie.

---
